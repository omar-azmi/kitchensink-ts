// import { } from "./binder.ts"
// import { } from "./builtin_aliases_deps.ts"
/*
const proxyAsSubclass = () => {

}
*/

const Ao = {
	id: "A",
	a() { console.log(this.id); return 1 },
	b() { console.log(this.id); return 2 },
	c() { console.log(this.id); return 3 },
	x: "x",
	y: "y",
	z: "z",
}

const Bo = {
	__proto__: Ao,
	id: "B",
	a() { super.a(); return 10 }
}

class A {
	id = "A"
	x = "x"
	y = "y"
	z = "z"
	a() { console.log("A.a()"); this.b(); return 1 }
	b() { console.log("A.b()"); this.c(); return 2 }
	c() { console.log("A.c()"); console.log(this.id, this.x, this.y, this.z); return 3 }
}

class B extends A {
	target
	id = "B"
	constructor(target) {
		super()
		this.target = target
	}
	// a() { super.a(); console.log(this.x, this.y, this.z); return 10 }
	b() { console.log("B.b()"); super.c(); return 20 }
	d() { console.log("B.d()"); console.log(this.id, this.x, this.y, this.z); return 40 }
}
/*
B.prototype = new Proxy(B.prototype, {
	get(target, prop, receiver) {
		console.log("GET", prop)
		return Reflect.get(target, prop, receiver)
	},
	getPrototypeOf(target) {
		console.log("SUPER DUPER!")
		return target
	},
})
*/

const subclassInIsolation = (subclass) => {
	// also don't forget getters and setters
	const
		target_symbol = Symbol(),
		super_methods_proxy_handler = {
			apply(targetMethod, thisArg, argsArr) {
				return Reflect.apply(targetMethod, thisArg[target_symbol] ?? thisArg, argsArr)
			}
		},
		proxied_super_proto = {}
	



}

Object.setPrototypeOf(B.prototype, {
	a: new Proxy(Object.getPrototypeOf(B.prototype).a, {
		apply(targetMethod, thisArg, argsArr) {
			return Reflect.apply(targetMethod, thisArg.target ?? thisArg, argsArr)
		}
	}),
	b: new Proxy(Object.getPrototypeOf(B.prototype).b, {
		apply(targetMethod, thisArg, argsArr) {
			return Reflect.apply(targetMethod, thisArg.target ?? thisArg, argsArr)
		}
	}),
	c: new Proxy(Object.getPrototypeOf(B.prototype).c, {
		apply(targetMethod, thisArg, argsArr) {
			return Reflect.apply(targetMethod, thisArg.target ?? thisArg, argsArr)
		}
	}),
})

// Object.setPrototypeOf(B.prototype, new Proxy(Object.getPrototypeOf(B.prototype), {
// 
// }))
/*
B.prototype.a = new Proxy(B.prototype.a, {
	apply(targetMethod, thisArg, argsArr) {
		return targetMethod.apply(thisArg.target, argsArr)
	}
})
B.prototype.b = new Proxy(B.prototype.b, {
	apply(targetMethod, thisArg, argsArr) {
		return targetMethod.apply(thisArg.target, argsArr)
	}
})
B.prototype.c = new Proxy(B.prototype.c, {
	apply(targetMethod, thisArg, argsArr) {
		return targetMethod.apply(thisArg.target, argsArr)
	}
})
*/
const a = new A()
const objB = new B(a)
objB.a()

// we want: A.a(), A.b(), A.c()
// thus we must intercept the call B.b(), because it already exists in the context of A()
// NO!, when we call super, we want to bind it to `target` instead of receiver
// NO!, proxy each method in A.method so that auto applies/binds to target instead of receiver 


class fakeA {
	id = "A"
	x = "x"
	y = "y"
	z = "z"
	a() { console.log("fakeA.a()"); this.b(); return 1 }
	b() { console.log("fakeA.b()"); this.c(); return 2 }
	c() { console.log("fakeA.c()"); console.log(this.id, this.x, this.y, this.z); return 3 }
}

const fakeb = new B()
fakeb.a()
console.log("------------")

//case 1
Object.setPrototypeOf(B.prototype, fakeA.prototype)
// B.prototype.a.apply({})
console.log("------------")


const B_proto = {
	__proto__: A.prototype, // this line is not necessary, but it helps typescript understand the context of `this` and `super`
	id: "B",
	// a() { super.a(); console.log(this.x, this.y, this.z); return 10 },
	b() { console.log("B.b()"); super.c(); return 20 },
	d() { console.log("B.d()"); console.log(this.id, this.x, this.y, this.z); return 40 }
}

const B_proxy_methods = {

}

const a = new A()
const b1 = Object.create(a, Object.getOwnPropertyDescriptors(B_proto))
const b2 = Object.setPrototypeOf(Object.create(a), B_proto)
const b3 = new Proxy(a, {
	/*
	get(t, p, r) {
		if(!Object.hasOwn(r, p)) {
			const value = r[p]
			return value.bind?.(r) ?? value
		}
	},
	*/
	getPrototypeOf(t) {
		console.log("SUPER DUPER!")
		return A.prototype
	},
})

const C_proto = {
	__proto__: A.prototype,

}


